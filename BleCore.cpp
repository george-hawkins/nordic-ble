#include <SPI.h>
#include <Streaming.h>
#include "BleUart.h"
#include <aci_setup.h>
#include "print_aci_evt.h"

// Get the service pipe data created in nRFGo Studio.
#ifdef SERVICES_PIPE_TYPE_MAPPING_CONTENT
static services_pipe_type_mapping_t services_pipe_type_mapping[] = SERVICES_PIPE_TYPE_MAPPING_CONTENT;
#else
static services_pipe_type_mapping_t* services_pipe_type_mapping = NULL;
const uint8_t NUMBER_OF_PIPES = 0;
#endif

// See also the second argument of lib_aci_init(..., debug) below.
const bool BLE_DEBUG = true;

// Store the nRF8001 setup in flash (this is required by the SDK and saves RAM).
const hal_aci_data_t setup_msgs[NB_SETUP_MESSAGES] PROGMEM = SETUP_MESSAGES_CONTENT;

void BleUart::begin(int8_t reqn_pin, int8_t rdyn_pin, int8_t reset_pin) {
    // Wire in the data generated by nRFGo Studio (services.h).
    aci_state.aci_setup_info.services_pipe_type_mapping = services_pipe_type_mapping;
    aci_state.aci_setup_info.number_of_pipes = NUMBER_OF_PIPES;
    aci_state.aci_setup_info.setup_msgs = const_cast<hal_aci_data_t*>(setup_msgs);
    aci_state.aci_setup_info.num_setup_msgs = NB_SETUP_MESSAGES;

    // Configure the MCU to nRF8001 pin connections.
    aci_state.aci_pins.board_name = BOARD_DEFAULT;
    aci_state.aci_pins.reqn_pin = reqn_pin;
    aci_state.aci_pins.rdyn_pin = rdyn_pin;
    aci_state.aci_pins.mosi_pin = MOSI;
    aci_state.aci_pins.miso_pin = MISO;
    aci_state.aci_pins.sck_pin = SCK;

    aci_state.aci_pins.spi_clock_divider = SPI_CLOCK_DIV8; // 2MHz SPI speed.

    aci_state.aci_pins.reset_pin = reset_pin;
    aci_state.aci_pins.active_pin = UNUSED;
    aci_state.aci_pins.optional_chip_sel_pin = UNUSED;

    aci_state.aci_pins.interface_is_interrupt = false;
    aci_state.aci_pins.interrupt_number = 1;

    // Initialize the host pins (including SPI). The nRF8001 itself is only setup later by do_aci_setup(...).
    lib_aci_init(&aci_state, false);
}

void BleUart::startAdvertising() {
    lib_aci_connect(adv_timeout, adv_interval);
}

// The setup_msgs contain a default device name and changing it is disabled by default. However if
// it was enabled in nRFgo Studio then there will be a pipe via which it can be updated like so...
void BleDeviceName::changeName(aci_state_t* aci_state) {
    lib_aci_set_local_data(aci_state, pipe, (uint8_t*)device_name, strlen(device_name));
}

// Handle low level ACI events.
void BleUart::pollAci() {
    hal_aci_evt_t aci_data;

    // If there's an ACI event available...
    if (lib_aci_event_get(&aci_state, &aci_data)) {
        aci_evt_t& aci_evt = aci_data.evt;

        if (BLE_DEBUG) {
            printAciEvtOpcode(aci_evt.evt_opcode);
        }

        // Note: the term "credit" seen at various points in this method is related to flow control.
        // For more information see aci.h and the "Flow control" section of the nRF8001 Product Specification.

        switch (aci_evt.evt_opcode) {
        // As soon as the nRF8001 is reset a device-started event is received.
        case ACI_EVT_DEVICE_STARTED:
            aci_state.data_credit_total = aci_evt.params.device_started.credit_available;
            switch (aci_evt.params.device_started.device_mode) {
            case ACI_DEVICE_SETUP: {
                // The device is in setup mode - transfer all the setup_msgs data to the nRF8001.
                uint8_t status = do_aci_setup(&aci_state);
                if (status != SETUP_SUCCESS) {
                    Serial << F("ACI setup failed with status 0x") << _HEX(status) << endl;
                    abort();
                }
                break;
            }

            case ACI_DEVICE_STANDBY:
                if (device_name != NULL) {
                    device_name->changeName(&aci_state);
                }
                startAdvertising();
            }
            break;

        case ACI_EVT_CMD_RSP:
            // If an ACI command response event comes with an error then halt.
            if (aci_evt.params.cmd_rsp.cmd_status != ACI_STATUS_SUCCESS) {
                // There are other non-error command response statuses in addition to ACI_STATUS_SUCCESS
                // but these are generally handled immediately in-place using lib_aci_event_peek(...).
                Serial << F("ACI command 0x") << _HEX(aci_evt.params.cmd_rsp.cmd_opcode) << F(" failed") << endl;
                abort();
            }
            break;

        case ACI_EVT_CONNECTED:
            aci_state.data_credit_available = aci_state.data_credit_total;
            timing.reset();
            break;

        case ACI_EVT_PIPE_STATUS:
            timing.changeTiming(&aci_state);
            break;

        case ACI_EVT_TIMING:
            // Link connection interval changed.
            break;

        case ACI_EVT_DISCONNECTED:
            startAdvertising();
            break;

        case ACI_EVT_DATA_RECEIVED:
            if (received_observer != NULL) {
                received_observer->received(aci_evt.params.data_received.rx_data.aci_data, aci_evt.len - 2);
            }
            break;

        case ACI_EVT_DATA_CREDIT:
            aci_state.data_credit_available = aci_state.data_credit_available + aci_evt.params.data_credit.credit;
            break;

        case ACI_EVT_PIPE_ERROR:
            // See the appendix in the nRF8001 Product Specification for details on the error codes.
            Serial << F("ACI_EVT_PIPE_ERROR: pipe=") << aci_evt.params.pipe_error.pipe_number << F(", error code=0x") << _HEX(aci_evt.params.pipe_error.error_code) << endl;

            // Increment the credit available as the data packet was not sent.
            aci_state.data_credit_available++;
            break;

        default:
            Serial << F("Unhandled event with opcode 0x") << _HEX(aci_evt.evt_opcode) << endl;
            break;
        }
    } else {
        // There's no event in the ACI event queue. If there's also no event in the ACI command
        // queue then the Arduino can go to sleep and wakeup from sleep from the RDYN line.
    }
}

// len must be less than or equal to ACI_PIPE_TX_DATA_MAX_LEN.
bool BleUart::write(const uint8_t* buffer, size_t len) {
    assert(len <= getMaxWriteLen());

    if (BLE_DEBUG) {
        Serial << F("Sending to BLE UART TX:");
        for (uint8_t i = 0; i < len; i++) {
            Serial << F(" 0x") << _HEX(buffer[i]);
        }
        Serial << endl;
    }

    bool available = lib_aci_is_pipe_available(&aci_state, PIPE_UART_OVER_BTLE_UART_TX_TX);

    if (available) {
        lib_aci_send_data(PIPE_UART_OVER_BTLE_UART_TX_TX, const_cast<uint8_t*>(buffer), len);
        aci_state.data_credit_available--;
        delay(35); // Required delay between sends.
    } else {
        pollAci();
    }

    return available;
}

void BleTiming::changeTiming(aci_state_t* aci_state) {
    if (!change_done) {
        aci_setup_info_t& info = aci_state->aci_setup_info;
        uint8_t localCount = 0;
        uint8_t localAvailable = 0;

        for (int i = 0; i < info.number_of_pipes; i++) {
            if (info.services_pipe_type_mapping[i].location == ACI_STORE_LOCAL) {
                localCount++;

                // The pipes are indexed from 1, the services_pipe_type_mapping from 0.
                if (lib_aci_is_pipe_available(aci_state, (i + 1))) {
                    localAvailable++;
                }
            }
        }

        // If there are local pipes then, once these pipes have all become available, apply
        // any connection timing settings (if any) that were configured in nRFgo Studio.
        if (localCount == localAvailable) {
            if (localCount > 0) {
                lib_aci_change_timing_GAP_PPCP();
            }
            change_done = true;
        }
    }
}

// The Nordic SDK requires the user to provide their own implementation of this method.
void __ble_assert(const char* file, uint16_t line) {
    Serial << F("Error - ") << file << F(": ") << line << endl;
    abort();
}
