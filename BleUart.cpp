#include <SPI.h>
#include <Streaming.h>
#include "BleUart.h"
#include <aci_setup.h>
#include <assert.h>
#include "print_aci_evt.h"

// Get the service pipe data created in nRFGo Studio.
#ifdef SERVICES_PIPE_TYPE_MAPPING_CONTENT
static services_pipe_type_mapping_t services_pipe_type_mapping[] = SERVICES_PIPE_TYPE_MAPPING_CONTENT;
#else
static services_pipe_type_mapping_t* services_pipe_type_mapping = NULL;
#define NUMBER_OF_PIPES 0
#endif

// See also the second argument of lib_aci_init(..., debug) below.
const bool BLE_DEBUG = true;

// Store the nRF8001 setup in flash (this is required by the SDK and saves RAM).
const hal_aci_data_t setup_msgs[NB_SETUP_MESSAGES] PROGMEM = SETUP_MESSAGES_CONTENT;

// adv_timeout - maximum advertising time in seconds (0 means infinite).
// adv_interval - advertising interval (in multiples of 0.625ms).
BleUart::BleUart(const char* device_name, uint16_t adv_timeout, uint16_t adv_interval) : adv_timeout(adv_timeout), adv_interval(adv_interval) {
    // The GAP Device Name pipe size can be changed but an upper limit is set by the fixed advertising packet size.
    assert(strlen(device_name) <= PIPE_GAP_DEVICE_NAME_SET_MAX_SIZE);

    memset(this->device_name, 0x00, sizeof(device_name));
    memcpy(this->device_name, device_name, strlen(device_name));
}

void BleUart::begin(int8_t reqn_pin, int8_t rdyn_pin, int8_t reset_pin) {
    // Wire in the data generated by nRFGo Studio (services.h).
    aci_state.aci_setup_info.services_pipe_type_mapping = services_pipe_type_mapping;
    aci_state.aci_setup_info.number_of_pipes = NUMBER_OF_PIPES;
    aci_state.aci_setup_info.setup_msgs = const_cast<hal_aci_data_t*>(setup_msgs);
    aci_state.aci_setup_info.num_setup_msgs = NB_SETUP_MESSAGES;

    // Configure the MCU to nRF8001 pin connections.
    aci_state.aci_pins.board_name = BOARD_DEFAULT;
    aci_state.aci_pins.reqn_pin = reqn_pin;
    aci_state.aci_pins.rdyn_pin = rdyn_pin;
    aci_state.aci_pins.mosi_pin = MOSI;
    aci_state.aci_pins.miso_pin = MISO;
    aci_state.aci_pins.sck_pin = SCK;

    aci_state.aci_pins.spi_clock_divider = SPI_CLOCK_DIV8; // 2MHz SPI speed.

    aci_state.aci_pins.reset_pin = reset_pin;
    aci_state.aci_pins.active_pin = UNUSED;
    aci_state.aci_pins.optional_chip_sel_pin = UNUSED;

    aci_state.aci_pins.interface_is_interrupt = false;
    aci_state.aci_pins.interrupt_number = 1;

    // Initialize the host pins (including SPI). The nRF8001 itself is only setup later by do_aci_setup(...).
    lib_aci_init(&aci_state, false);
}

void BleUart::startAdvertising() {
    lib_aci_connect(adv_timeout, adv_interval);
}

// Handle low level ACI events.
void BleUart::pollACI() {
    hal_aci_evt_t aci_data;

    // If there's an ACI event available...
    if (lib_aci_event_get(&aci_state, &aci_data)) {
        aci_evt_t& aci_evt = aci_data.evt;

        if (BLE_DEBUG) {
            printAciEvtOpcode(aci_evt.evt_opcode);
        }

        // Note: the term "credit" seen at various points in this method is related to flow control.
        // For more information see aci.h and the "Flow control" section of the nRF8001 Product Specification.

        switch (aci_evt.evt_opcode) {
        // As soon as the nRF8001 is reset a device-started event is received.
        case ACI_EVT_DEVICE_STARTED:
            aci_state.data_credit_total = aci_evt.params.device_started.credit_available;
            switch (aci_evt.params.device_started.device_mode) {
            case ACI_DEVICE_SETUP: {
                // The device is in setup mode - transfer all the setup_msgs data to the nRF8001.
                uint8_t status = do_aci_setup(&aci_state);
                if (status != SETUP_SUCCESS) {
                    Serial << F("ACI setup failed with status 0x") << _HEX(status) << endl;
                    abort();
                }
                break;
            }

            case ACI_DEVICE_STANDBY:
                if (device_name[0] != 0x00) {
                    // The setup_msgs contain a default device name and changing it is disabled by default.
                    // However if updating it was enabled in nRFgo Studio then...
                    lib_aci_set_local_data(&aci_state, PIPE_GAP_DEVICE_NAME_SET, (uint8_t*)&device_name, strlen(device_name));
                }
                startAdvertising();
            }
            break;

        case ACI_EVT_CMD_RSP:
            // If an ACI command response event comes with an error then halt.
            if (aci_evt.params.cmd_rsp.cmd_status & 0x80 != ACI_STATUS_SUCCESS) {
                // There are other non-error command response statuses in addition to ACI_STATUS_SUCCESS
                // but these are generally handled immediately in-place using lib_aci_event_peek(...).
                Serial << F("ACI command 0x") << _HEX(aci_evt.params.cmd_rsp.cmd_opcode) << F(" failed") << endl;
                abort();
            }
            if (aci_evt.params.cmd_rsp.cmd_opcode == ACI_CMD_GET_DEVICE_VERSION) {
                // For information of the Device Information (DI) service see:
                // * https://developer.bluetooth.org/TechnologyOverview/Pages/DIS.aspx and
                // * https://developer.bluetooth.org/gatt/services/Pages/ServiceViewer.aspx?u=org.bluetooth.service.device_information.xml

                // Most of the Nordic nRF8001 examples, in addition to the main service, include the DI service.
                // All DI characteristics are optional and in these example just the Hardware Revision String in included.
                // The Hardware Revision String should be a UTF8 string - however Nordic simply store the blob
                // of bytes that make up the aci_evt_cmd_rsp_params_get_device_version_t structure in it.
                // This isn't ideal as an arbitrary byte sequence is unlikely to be printable and is not guaranteed to be valid UTF-8:
                // http://en.wikipedia.org/wiki/UTF-8#Invalid_byte_sequences
                assert(sizeof(aci_evt_cmd_rsp_params_get_device_version_t) <= PIPE_DEVICE_INFORMATION_HARDWARE_REVISION_STRING_SET_MAX_SIZE);

                lib_aci_set_local_data(&aci_state,
                        PIPE_DEVICE_INFORMATION_HARDWARE_REVISION_STRING_SET,
                        (uint8_t*)&(aci_evt.params.cmd_rsp.params.get_device_version),
                        sizeof(aci_evt_cmd_rsp_params_get_device_version_t));

                if (BLE_DEBUG) {
                    aci_evt_cmd_rsp_params_get_device_version_t& version = aci_evt.params.cmd_rsp.params.get_device_version;

                    // Three of the values are just the same values as the macro values ACI_VERSION, SETUP_FORMAT and SETUP_ID.
                    Serial << F("Device version") <<
                            F(": aci_version=0x") << _HEX(version.aci_version) <<
                            F(", configuration_id=0x") << _HEX(version.configuration_id) <<
                            F(", setup_format=0x") << _HEX(version.setup_format) <<
                            F(", setup_id=0x") << _HEX(version.setup_id) <<
                            F(", setup_status=0x") << _HEX(version.setup_status) <<
                            endl;
                }
            }
            break;

        case ACI_EVT_CONNECTED:
            aci_state.data_credit_available = aci_state.data_credit_total;
            timing_manager.reset();

            // Request the device version - response comes back with cmd_opcode ACI_CMD_GET_DEVICE_VERSION (see above).
            lib_aci_device_version();
            break;

        case ACI_EVT_PIPE_STATUS:
            timing_manager.changeTiming(&aci_state);
            break;

        case ACI_EVT_TIMING:
            // Link connection interval changed.
            break;

        case ACI_EVT_DISCONNECTED:
            startAdvertising();
            break;

        case ACI_EVT_DATA_RECEIVED:
            if (received_observer != NULL) {
                received_observer->received(aci_evt.params.data_received.rx_data.aci_data, aci_evt.len - 2);
            }
            break;

        case ACI_EVT_DATA_CREDIT:
            aci_state.data_credit_available = aci_state.data_credit_available + aci_evt.params.data_credit.credit;
            break;

        case ACI_EVT_PIPE_ERROR:
            // See the appendix in the nRF8001 Product Specification for details on the error codes.
            Serial << F("ACI_EVT_PIPE_ERROR: pipe=") << aci_evt.params.pipe_error.pipe_number << F(", error code=0x") << _HEX(aci_evt.params.pipe_error.error_code) << endl;

            // Increment the credit available as the data packet was not sent.
            aci_state.data_credit_available++;
            break;

        default:
            Serial << F("Unhandled event with opcode 0x") << _HEX(aci_evt.evt_opcode) << endl;
            break;
        }
    } else {
        // There's no event in the ACI event queue. If there's also no event in the ACI command
        // queue then the Arduino can go to sleep and wakeup from sleep from the RDYN line.
    }
}

// len must be less than or equal to ACI_PIPE_TX_DATA_MAX_LEN.
bool BleUart::write(const uint8_t* buffer, size_t len) {
    assert(len <= getMaxWriteLen());

    if (BLE_DEBUG) {
        Serial << F("Sending to BLE UART TX:");
        for (uint8_t i = 0; i < len; i++) {
            Serial << F(" 0x") << _HEX(buffer[i]);
        }
        Serial << endl;
    }

    bool available = lib_aci_is_pipe_available(&aci_state, PIPE_UART_OVER_BTLE_UART_TX_TX);

    if (available) {
        lib_aci_send_data(PIPE_UART_OVER_BTLE_UART_TX_TX, const_cast<uint8_t*>(buffer), len);
        aci_state.data_credit_available--;
        delay(35); // Required delay between sends.
    } else {
        pollACI();
    }

    return available;
}

void BleTimingManager::changeTiming(aci_state_t* aci_state) {
    if (!change_done) {
        aci_setup_info_t& info = aci_state->aci_setup_info;
        uint8_t localCount = 0;
        uint8_t localAvailable = 0;

        for (int i = 0; i < info.number_of_pipes; i++) {
            if (info.services_pipe_type_mapping[i].location == ACI_STORE_LOCAL) {
                localCount++;

                // The pipes are indexed from 1, the services_pipe_type_mapping from 0.
                if (lib_aci_is_pipe_available(aci_state, (i + 1))) {
                    localAvailable++;
                }
            }
        }

        // If there are local pipes then, once these pipes have all become available, apply
        // any connection timing settings (if any) that were configured in nRFgo Studio.
        if (localCount == localAvailable) {
            if (localCount > 0) {
                lib_aci_change_timing_GAP_PPCP();
            }
            change_done = true;
        }
    }
}

// The Nordic SDK requires the user to provide their own implementation of this method.
void __ble_assert(const char* file, uint16_t line) {
    Serial << F("Error - ") << file << F(": ") << line << endl;
    abort();
}
