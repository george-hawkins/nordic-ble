/**
 * Copyright 2014 George C. Hawkins
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include <SPI.h>
#include <Streaming.h>
#include "BleCore.h"
#include <aci_setup.h>
#include "print_aci_info.h"

// See also the second argument of lib_aci_init(..., debug) below.
const bool BLE_DEBUG = true;

void BleCore::begin(aci_setup_info_t& info, int8_t reqn_pin, int8_t rdyn_pin, int8_t reset_pin) {
    // Wire in the data generated by nRFGo Studio (services.h).
    aci_state.aci_setup_info = info;

    // Configure the MCU to nRF8001 pin connections.
    aci_state.aci_pins.board_name = BOARD_DEFAULT;
    aci_state.aci_pins.reqn_pin = reqn_pin;
    aci_state.aci_pins.rdyn_pin = rdyn_pin;
    aci_state.aci_pins.mosi_pin = MOSI;
    aci_state.aci_pins.miso_pin = MISO;
    aci_state.aci_pins.sck_pin = SCK;

    aci_state.aci_pins.spi_clock_divider = SPI_CLOCK_DIV8; // 2MHz SPI speed.

    aci_state.aci_pins.reset_pin = reset_pin;
    aci_state.aci_pins.active_pin = UNUSED;
    aci_state.aci_pins.optional_chip_sel_pin = UNUSED;

    aci_state.aci_pins.interface_is_interrupt = false;
    aci_state.aci_pins.interrupt_number = 1;

    // Initialize the host pins (including SPI) and hard reset the nRF8001 (if the reset_pin is set) and soft reset its radio.
    // The nRF8001 itself is only setup later by do_aci_setup(...).
    lib_aci_init(&aci_state, false);
}

void BleCore::startAdvertising() {
    lib_aci_connect(adv_timeout, adv_interval);
}

// The setup_msgs contain a default device name and changing it is disabled by default. However if it
// was enabled in the configuration then there will be a pipe via which it can be updated like so...
void BleDeviceName::changeName(aci_state_t* aci_state) {
    lib_aci_set_local_data(aci_state, pipe, (uint8_t*)device_name, strlen(device_name));
}

// Attempts to get and handle the next ACI event - returns false if there is no event.
bool BleCore::handleAciEvent() {
    hal_aci_evt_t aci_data;

    if (lib_aci_event_get(&aci_state, &aci_data)) {
        // There's no event in the ACI event queue - so the caller could go into deep
        // sleep, waiting to be woken by an interrupt event occurring on the RDYN pin.
        return false;
    }

    aci_evt_t& aci_evt = aci_data.evt;

    if (BLE_DEBUG) {
        printAciInfo(aci_state, aci_evt);
    }

    // Note: the term "credit" seen at various points in this method is related to flow control.
    // For more information see aci.h and section 21 "Flow control" in the nRF8001 Product Specification.

    switch (aci_evt.evt_opcode) {
    // As soon as the nRF8001 is reset a device-started event is received.
    case ACI_EVT_DEVICE_STARTED:
        aci_state.data_credit_total = aci_evt.params.device_started.credit_available;
        aci_state.data_credit_available = 0;

        switch (aci_evt.params.device_started.device_mode) {
        case ACI_DEVICE_SETUP: {
            // The device is in setup mode - transfer all the setup_msgs data to the nRF8001.
            uint8_t status = do_aci_setup(&aci_state);
            if (status != SETUP_SUCCESS) {
                Serial << F("do_aci_setup failed (reason=0x") << _HEX(status) << F(")") << endl;
                abort();
            }
            break;
        }

        case ACI_DEVICE_STANDBY:
            if (aci_evt.params.device_started.hw_error) {
                // A fatal error occurred in the nRF8001 firmware - an ACI_EVT_HW_ERROR will follow with debug information.
                delay(20);
                // Nordic added this "magic" delay on Jan 30th, 2014 to one of their examples and subsequently to all others.
                // See https://github.com/NordicSemiconductor/ble-sdk-arduino/commit/177b407
            } else {
                if (device_name != NULL) {
                    device_name->changeName(&aci_state);
                }
                startAdvertising();
            }
        }
        break;

    case ACI_EVT_CMD_RSP:
        // There are other non-error command response statuses in addition to ACI_STATUS_SUCCESS
        // but these are generally handled immediately in-place using lib_aci_event_peek(...).
        if (aci_evt.params.cmd_rsp.cmd_status != ACI_STATUS_SUCCESS) {
            // printAciInfo will output the details (opcode and status).
            abort(); // Adafruit stop on a failure, Nordic do not.
        }
        break;

    case ACI_EVT_CONNECTED:
        aci_state.data_credit_available = aci_state.data_credit_total;
        timing.reset();
        break;

    case ACI_EVT_PIPE_STATUS:
        timing.changeTiming(&aci_state);
        break;

    case ACI_EVT_TIMING:
        // Link connection interval changed.
        break;

    case ACI_EVT_DISCONNECTED: // Disconnected or advertising timed out.
        aci_state.data_credit_available = 0;
        startAdvertising();
        break;

    case ACI_EVT_DATA_RECEIVED:
        if (received_observer != NULL) {
            aci_rx_data_t& data = aci_evt.params.data_received.rx_data;

            // aci_evt.len is the packet length. In addition to the data-received bytes the packet contains:
            // * the opcode, i.e. ACI_EVT_DATA_RECEIVED - aci_evt.evt_opcode.
            // * the pipe number - aci_evt.params.data_received.rx_data.pipe_number.
            // So the number of data-received bytes is aci_evt.len minus these two bytes.
            received_observer->received(data.pipe_number, data.aci_data, aci_evt.len - 2);
        }
        break;

    case ACI_EVT_DATA_CREDIT:
        aci_state.data_credit_available += aci_evt.params.data_credit.credit;
        break;

    case ACI_EVT_PIPE_ERROR:
        // printAciInfo will output the error details (pipe and code).
        // PEER_ATT_ERROR means the peer device sent an error - this doesn't affect our credit.
        // For all cases increment the credit available as no packet was sent.
        if (aci_evt.params.pipe_error.error_code != ACI_STATUS_ERROR_PEER_ATT_ERROR) {
            aci_state.data_credit_available++;
        }
        break;

    case ACI_EVT_HW_ERROR:
        // Start advertising again after an error in the nRF8001 firmware (printAciInfo will output the location of the error).
        startAdvertising();
        break;

    default:
        Serial << F("Unhandled event with opcode 0x") << _HEX(aci_evt.evt_opcode) << endl;
        break;
    }

    return true;
}

bool BleCore::write(uint8_t pipe, size_t pipe_max_len, const uint8_t* buffer, size_t len) {
    assert(len <= pipe_max_len);

    if (BLE_DEBUG) {
        Serial << F("Sending to pipe ") << (int)pipe << F(": ");
        printByteArray(buffer, len);
        Serial << endl;
    }

    bool ok =
            aci_state.data_credit_available > 0 &&
            lib_aci_is_pipe_available(&aci_state, pipe) &&
            lib_aci_send_data(pipe, const_cast<uint8_t*>(buffer), len);

    if (ok) {
        aci_state.data_credit_available--;
        delay(35); // Required delay between sends.
    } else {
        handleAciEvent();
    }

    // Only the Adafruit code includes either the delay or the event handling call - Nordic has neither.
    // A 35ms delay seems massive (given the connection interval can be 7.5ms) so investigation could well show it's not required.

    return ok;
}

void BleTiming::changeTiming(aci_state_t* aci_state) {
    if (!change_done) {
        aci_setup_info_t& info = aci_state->aci_setup_info;
        uint8_t localCount = 0;
        uint8_t localAvailable = 0;

        for (int i = 0; i < info.number_of_pipes; i++) {
            if (info.services_pipe_type_mapping[i].location == ACI_STORE_LOCAL) {
                localCount++;

                // The pipes are indexed from 1, the services_pipe_type_mapping from 0.
                if (lib_aci_is_pipe_available(aci_state, (i + 1))) {
                    localAvailable++;
                }
            }
        }

        // If there are local pipes then, once these pipes have all become available, apply
        // any connection timing settings (if any) that were configured in nRFgo Studio.
        if (localCount == localAvailable) {
            if (localCount == 0 || lib_aci_change_timing_GAP_PPCP()) {
                change_done = true;
            }
        }
    }
}

// The Nordic SDK requires the user to provide their own implementation of this method.
void __ble_assert(const char* file, uint16_t line) {
    Serial << F("Error - ") << file << F(": ") << line << endl;
    abort();
}
