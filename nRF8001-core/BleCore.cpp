#include <SPI.h>
#include <Streaming.h>
#include "BleCore.h"
#include <aci_setup.h>
#include "print_aci_info.h"

// See also the second argument of lib_aci_init(..., debug) below.
const bool BLE_DEBUG = true;

void BleCore::begin(aci_setup_info_t& info, int8_t reqn_pin, int8_t rdyn_pin, int8_t reset_pin) {
    // Wire in the data generated by nRFGo Studio (services.h).
    aci_state.aci_setup_info = info;

    // Configure the MCU to nRF8001 pin connections.
    aci_state.aci_pins.board_name = BOARD_DEFAULT;
    aci_state.aci_pins.reqn_pin = reqn_pin;
    aci_state.aci_pins.rdyn_pin = rdyn_pin;
    aci_state.aci_pins.mosi_pin = MOSI;
    aci_state.aci_pins.miso_pin = MISO;
    aci_state.aci_pins.sck_pin = SCK;

    aci_state.aci_pins.spi_clock_divider = SPI_CLOCK_DIV8; // 2MHz SPI speed.

    aci_state.aci_pins.reset_pin = reset_pin;
    aci_state.aci_pins.active_pin = UNUSED;
    aci_state.aci_pins.optional_chip_sel_pin = UNUSED;

    aci_state.aci_pins.interface_is_interrupt = false;
    aci_state.aci_pins.interrupt_number = 1;

    // Initialize the host pins (including SPI) and hard reset the nRF8001 (if the reset_pin is set) and soft reset its radio.
    // The nRF8001 itself is only setup later by do_aci_setup(...).
    lib_aci_init(&aci_state, false);
}

void BleCore::startAdvertising() {
    lib_aci_connect(adv_timeout, adv_interval);
}

// The setup_msgs contain a default device name and changing it is disabled by default. However if it
// was enabled in the configuration then there will be a pipe via which it can be updated like so...
void BleDeviceName::changeName(aci_state_t* aci_state) {
    lib_aci_set_local_data(aci_state, pipe, (uint8_t*)device_name, strlen(device_name));
}

// Handle low level ACI events.
void BleCore::pollAci() {
    hal_aci_evt_t aci_data;

    // If there's an ACI event available...
    if (lib_aci_event_get(&aci_state, &aci_data)) {
        aci_evt_t& aci_evt = aci_data.evt;

        if (BLE_DEBUG) {
            printAciInfo(aci_state, aci_evt);
        }

        // Note: the term "credit" seen at various points in this method is related to flow control.
        // For more information see aci.h and the "Flow control" section of the nRF8001 Product Specification.

        switch (aci_evt.evt_opcode) {
        // As soon as the nRF8001 is reset a device-started event is received.
        case ACI_EVT_DEVICE_STARTED:
            aci_state.data_credit_total = aci_evt.params.device_started.credit_available;
            switch (aci_evt.params.device_started.device_mode) {
            case ACI_DEVICE_SETUP: {
                // The device is in setup mode - transfer all the setup_msgs data to the nRF8001.
                uint8_t status = do_aci_setup(&aci_state);
                if (status != SETUP_SUCCESS) {
                    Serial << F("ACI setup failed with status 0x") << _HEX(status) << endl;
                    abort();
                }
                break;
            }

            case ACI_DEVICE_STANDBY:
                if (device_name != NULL) {
                    device_name->changeName(&aci_state);
                }
                startAdvertising();
            }
            break;

        case ACI_EVT_CMD_RSP:
            // There are other non-error command response statuses in addition to ACI_STATUS_SUCCESS
            // but these are generally handled immediately in-place using lib_aci_event_peek(...).
            if (aci_evt.params.cmd_rsp.cmd_status != ACI_STATUS_SUCCESS) {
                // printAciInfo will output the details (opcode and status).
                abort(); // Adafruit stop on a failure, Nordic do not.
            }
            break;

        case ACI_EVT_CONNECTED:
            aci_state.data_credit_available = aci_state.data_credit_total;
            timing.reset();
            break;

        case ACI_EVT_PIPE_STATUS:
            timing.changeTiming(&aci_state);
            break;

        case ACI_EVT_TIMING:
            // Link connection interval changed.
            break;

        case ACI_EVT_DISCONNECTED: // Disconnected or advertising timed out.
            startAdvertising();
            break;

        case ACI_EVT_DATA_RECEIVED:
            if (received_observer != NULL) {
                aci_rx_data_t& data = aci_evt.params.data_received.rx_data;

                // aci_evt.len is the packet length. In addition to the data-received bytes the packet contains:
                // * the opcode, i.e. ACI_EVT_DATA_RECEIVED - aci_evt.evt_opcode.
                // * the pipe number - aci_evt.params.data_received.rx_data.pipe_number.
                // So the number of data-received bytes is aci_evt.len minus these two bytes.
                received_observer->received(data.pipe_number, data.aci_data, aci_evt.len - 2);
            }
            break;

        case ACI_EVT_DATA_CREDIT:
            aci_state.data_credit_available = aci_state.data_credit_available + aci_evt.params.data_credit.credit;
            break;

        case ACI_EVT_PIPE_ERROR:
            // printAciInfo will output the details (pipe and error code).
            // For all cases, other than a peer ATT error, increment the credit available as no packet was sent.
            if (aci_evt.params.pipe_error.error_code != ACI_STATUS_ERROR_PEER_ATT_ERROR) {
                aci_state.data_credit_available++;
            }
            break;

        default:
            Serial << F("Unhandled event with opcode 0x") << _HEX(aci_evt.evt_opcode) << endl;
            break;
        }
    } else {
        // There's no event in the ACI event queue. If there's also no event in the ACI command queue then
        // the Arduino can go to sleep and wake only when an interrupt event occurs on the RDYN pin.
    }
}

bool BleCore::write(uint8_t pipe, size_t pipe_max_len, const uint8_t* buffer, size_t len) {
    assert(len <= pipe_max_len);

    if (BLE_DEBUG) {
        Serial << F("Sending to pipe ") << (int)pipe << F(": ");
        for (uint8_t i = 0; i < len; i++) {
            Serial << F(" 0x") << _HEX(buffer[i]);
        }
        Serial << endl;
    }

    bool ok =
            aci_state.data_credit_available > 0 &&
            lib_aci_is_pipe_available(&aci_state, pipe) &&
            lib_aci_send_data(pipe, const_cast<uint8_t*>(buffer), len);

    if (ok) {
        aci_state.data_credit_available--;
        delay(35); // Required delay between sends.
    } else {
        pollAci();
    }

    // Only the Adafruit code includes either the delay(...) or polling - Nordic has neither.
    // A 35ms delay seems massive (given the connection interval can be 7.5ms) so investigation could well show it's not required.

    return ok;
}

void BleTiming::changeTiming(aci_state_t* aci_state) {
    if (!change_done) {
        aci_setup_info_t& info = aci_state->aci_setup_info;
        uint8_t localCount = 0;
        uint8_t localAvailable = 0;

        for (int i = 0; i < info.number_of_pipes; i++) {
            if (info.services_pipe_type_mapping[i].location == ACI_STORE_LOCAL) {
                localCount++;

                // The pipes are indexed from 1, the services_pipe_type_mapping from 0.
                if (lib_aci_is_pipe_available(aci_state, (i + 1))) {
                    localAvailable++;
                }
            }
        }

        // If there are local pipes then, once these pipes have all become available, apply
        // any connection timing settings (if any) that were configured in nRFgo Studio.
        if (localCount == localAvailable) {
            if (localCount == 0 || lib_aci_change_timing_GAP_PPCP()) {
                change_done = true;
            }
        }
    }
}

// The Nordic SDK requires the user to provide their own implementation of this method.
void __ble_assert(const char* file, uint16_t line) {
    Serial << F("Error - ") << file << F(": ") << line << endl;
    abort();
}
